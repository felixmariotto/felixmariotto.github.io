<!DOCTYPE html>
<html>
<head>
	<title>example spriteMixer 2</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no">
	<script src="./libs/three.js"></script>
	<script src="./libs/stats.min.js"></script>
	<script src="./tools/SpriteMixer.js"></script>

	<style type="text/css">

		* {
			font-family: Courier;
			margin: 0;
			padding: 0;
		}

		body {
			position: fixed;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		#btn-container {
			position: fixed;
			bottom: 20px;
			left: 50%;
			transform: translate(-50%);
			text-align: center;
			display: flex;
			flex-direction: column;
		}

			#btn-container>div {
				margin-bottom: 15px;
			}

		button {
			font-size: 1.2em;
			padding: 8px;
		}

		a {
			font-size: 1.2em;
			padding: 12px;
			border-radius: 10px;
			background-color: #999999;
		}

	</style>

</head>



<body>


	<div id="btn-container">
		<div>
			<button onclick="play()">PLAY</button>
			<button onclick="pause()">PAUSE</button>
		</div>
		<a target='_blank' href="https://github.com/felixmariotto/three-SpriteMixer">< Source code ></a>
	</div>




	<script type="text/javascript">


		window.addEventListener('load', function() {
			main();
			loop();
		})
		
		
		var scene, renderer, camera, controls, clock, stats;
		const WIDTH = window.innerWidth;
		const HEIGHT = window.innerHeight;



		///////////////////////
		///	INITIALISATION
		///////////////////////

		var spriteMixer = SpriteMixer();
		var group;
		var actions = []; // This will store the actionSprites that we want to play, in playing order.
		var actionToPlay = 0 ;





		//////////////////////////////////////////
		/// DIFFERENT WAYS OF USING ACTIONSPRITES
		//////////////////////////////////////////
		// In the examples bellow it is shown how to loop through
		// all your actionSprites, but of course you can animate
		// them independently.

		function onClickPlay() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].playOnce();
				// Set the .visible = true.
				// Restart the animation from frame 0.
				// Set .paused = false -> animate at next update in the loop.
				// Set .mustLoop = false.
			};
		};

		function onClickResume() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].resume();
				// Set the .visible = true.
				// Set .paused = false -> animate at next update in the loop.
				// Unlike .playOnce(), it does not restart at frame 0.
			};
		};

		function onClickPlayLoop() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].playLoop();
				// Set the .visible = true.
				// Restart the animation from frame 0.
				// Set .paused = false -> animate at next update in the loop.
				// Set .mustLoop = true -> animation will restart at last frame.
			};
		};

		function onClickPauseNext() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].pauseNextEnd();
				// Set .mustLoop = false -> animation will pause at last frame.
			};
		};

		function onClickPause() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].pause();
				// Set sprite.paused = true -> next update in the loop 
				// will have no effect.
			};
		};

		function onClickStop() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].stop();
				// Restart the animation
				// Set .paused = true -> Animation will pause at frame 0.
				// If .hideWhenFinished == true, then set .visible = false.
			};
		};

		function onClickHide() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].hideWhenFinished =
					!spriteMixer.actionSprites[i].hideWhenFinished;
				// If .hideWhenFinished == true, .visible will be
				// set to false at the end of the animation.
			};
		};

		function onClickClamp() {
			for (let i=0 ; i<spriteMixer.actionSprites.length ; i++) {
				spriteMixer.actionSprites[i].clampWhenFinished =
					!spriteMixer.actionSprites[i].clampWhenFinished;
				// If .clampWhenFinished == true, animation will pause a last
				// frame when it finishes.
			};
		};












		function main() {


			///////////////////////////
			///	BASIC THREE.JS CODE
			///////////////////////////

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x666666);

			camera = new THREE.PerspectiveCamera(30, WIDTH/HEIGHT, 0.1, 1000);
			camera.position.set(0, 8, 30);
			camera.lookAt(0, 0, 0);

			renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
			renderer.setSize(WIDTH, HEIGHT);
			document.body.appendChild(renderer.domElement);

			clock = new THREE.Clock();

			stats = new Stats();
			document.body.appendChild(stats.dom);

			group = new THREE.Group();
			scene.add( group );







			////////////////////
			///	CUSTOM CODE
			////////////////////

			/*
				ActionSprite(textureURL:string, tilesHoriz:integer, tilesVert:integer, numTiles:integer, tileDispDuration:integer)
					- texture : THREE.Texture contaning the tiles of an animation in a grid.
					- tilesHoriz : number of frames on the horizontal direction.
					- tilesVert : number of frames on the vertical direction.
					- numTiles : total number of frames. As you can see in the exemples,
					  it does not necessarily equal tilesHoriz*tilesVert, for instance
					  if the last frames are empty.
					- tileDispDuration : display duration of ONE FRAME, un milliseconds.

				spriteMixer.ActionSprite() returns a extended THREE.Sprite .
				All the parameters necessary for the animation are stored inside,
				but you can still use it as any THREE.Sprite, like scale it etc.
			*/

			var loader = new THREE.TextureLoader();
			
			loader.load("./textures/splash.png", (texture)=> {
				splash = spriteMixer.ActionSprite(texture, 4, 3, 7, 55);
				splash.paused = true ;
				splash.hideWhenFinished = true ;
				splash.clampWhenFinished = false ;
				splash.scale.set(4, 4, 1);
				group.add( splash );
				actions[0] = splash ;
			});
			
			loader.load("./textures/land.png", (texture)=> {
				land = spriteMixer.ActionSprite(texture, 4, 3, 8, 55);
				land.paused = true ;
				land.paused = false ;
				land.hideWhenFinished = true ;
				land.clampWhenFinished = false ;
				land.scale.set(4, 4, 1);
				group.add( land );
				actions[1] = land ;
			});
			

			loader.load("./textures/smoke_grey.png", (texture)=> {
				smokeGrey = spriteMixer.ActionSprite(texture, 3, 3, 9, 55);
				smokeGrey.paused = true ;
				smokeGrey.visible = false ;
				smokeGrey.hideWhenFinished = true ;
				smokeGrey.clampWhenFinished = false ;
				smokeGrey.scale.set(4, 4, 1);
				group.add( smokeGrey );
				actions[2] = smokeGrey ;
			});
			

			loader.load("./textures/smoke_white.png", (texture)=> {
				smokeWhite = spriteMixer.ActionSprite(texture, 3, 3, 9, 55);
				smokeWhite.paused = true ;
				smokeWhite.visible = false ;
				smokeWhite.hideWhenFinished = true ;
				smokeWhite.clampWhenFinished = false ;
				smokeWhite.scale.set(4, 4, 1);
				group.add( smokeWhite );
				actions[3] = smokeWhite ;
			});




			spriteMixer.addEventListener('finished', function(event) {
				actionToPlay = ( actionToPlay + 1 ) % 4 ;
				play();
			});

			
		};




		function play() {
			actions[ actionToPlay ].playOnce();
		};




		function pause() {
			actions[ actionToPlay ].pause();
		};





		function loop() {
			requestAnimationFrame(loop);
			renderer.render(scene, camera);
			stats.update();

			var delta = clock.getDelta();
			
			/////////////////////
			///	   UPDATE
			/////////////////////
			spriteMixer.update(delta);
		};



	</script>
	

</body>
</html>
